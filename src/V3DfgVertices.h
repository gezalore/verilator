// -*- mode: C++; c-file-style: "cc-mode" -*-
//*************************************************************************
// DESCRIPTION: Verilator: DfgVertex sub-classes
//
// Code available from: https://verilator.org
//
//*************************************************************************
//
// Copyright 2003-2025 by Wilson Snyder. This program is free software; you
// can redistribute it and/or modify it under the terms of either the GNU
// Lesser General Public License Version 3 or the Perl Artistic License
// Version 2.0.
// SPDX-License-Identifier: LGPL-3.0-only OR Artistic-2.0
//
//*************************************************************************
//
// This is a data-flow graph based representation of combinational logic,
// the main difference from a V3Graph is that DfgVertex owns the storage
// of it's input edges (operands/sources/arguments), and can access each
// input edge directly by indexing, making modifications more efficient
// than the linked list based structures used by V3Graph.
//
// A bulk of the DfgVertex sub-types are generated by astgen, and are
// analogous to the corresponding AstNode sub-types.
//
// See also the internals documentation docs/internals.rst
//
//*************************************************************************

#ifndef VERILATOR_V3DFGVERTICES_H_
#define VERILATOR_V3DFGVERTICES_H_

#ifndef VERILATOR_V3DFG_H_
#error "Use V3Dfg.h as the include"
#include "V3Dfg.h"  // This helps code analysis tools pick up symbols in V3Dfg.h
#define VL_NOT_FINAL  // This #define fixes broken code folding in the CLion IDE
#endif

// Include macros generated by 'astgen'. These include DFGGEN_MEMBERS_<Node>
// for each DfgVertex sub-type. The generated members include boilerplate
// methods related to cloning, visitor dispatch, and other functionality.
// For precise details please read the generated macros.
#include "V3Dfg__gen_macros.h"

//------------------------------------------------------------------------------
// Dfg vertices with a fixed number of sources

//------------------------------------------------------------------------------
// Abstract base DfgVertex sub-types

class DfgVertexBinary VL_NOT_FINAL : public DfgVertex {
    DfgEdge m_srcs[2] = {DfgEdge{this}, DfgEdge{this}};

protected:
    DfgVertexBinary(DfgGraph& dfg, VDfgType type, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertex{dfg, type, flp, dtypep} {}

public:
    ASTGEN_MEMBERS_DfgVertexBinary;

    DfgVertex* src0p() const { return m_srcs[0].sourcep(); }
    void src0p(DfgVertex* vtxp) { m_srcs[0].relinkSource(vtxp); }
    DfgVertex* src1p() const { return m_srcs[1].sourcep(); }
    void src1p(DfgVertex* vtxp) { m_srcs[1].relinkSource(vtxp); }
};
class DfgVertexNullary VL_NOT_FINAL : public DfgVertex {
    DfgEdge m_srcs[1] = {DfgEdge{this}};

protected:
    DfgVertexNullary(DfgGraph& dfg, VDfgType type, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertex{dfg, type, flp, dtypep} {}

public:
    ~DfgVertexNullary() = default;

    ASTGEN_MEMBERS_DfgVertexNullary;

    std::string srcName(size_t) const override final { V3ERROR_NA_RETURN(""); }
};
class DfgVertexTernary VL_NOT_FINAL : public DfgVertex {
    DfgEdge m_srcs[3] = {DfgEdge{this}, DfgEdge{this}, DfgEdge{this}};

protected:
    DfgVertexTernary(DfgGraph& dfg, VDfgType type, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertex{dfg, type, flp, dtypep} {}

public:
    ASTGEN_MEMBERS_DfgVertexTernary;

    DfgVertex* src0p() const { return m_srcs[0].sourcep(); }
    void src0p(DfgVertex* vtxp) { m_srcs[0].relinkSource(vtxp); }
    DfgVertex* src1p() const { return m_srcs[1].sourcep(); }
    void src1p(DfgVertex* vtxp) { m_srcs[1].relinkSource(vtxp); }
    DfgVertex* src2p() const { return m_srcs[2].sourcep(); }
    void src2p(DfgVertex* vtxp) { m_srcs[2].relinkSource(vtxp); }
};
class DfgVertexUnary VL_NOT_FINAL : public DfgVertex {
    DfgEdge m_srcs[1] = {DfgEdge{this}};

protected:
    DfgVertexUnary(DfgGraph& dfg, VDfgType type, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertex{dfg, type, flp, dtypep} {}

public:
    ASTGEN_MEMBERS_DfgVertexUnary;

    DfgVertex* src0p() const { return m_srcs[0].sourcep(); }
    void src0p(DfgVertex* vtxp) { m_srcs[0].relinkSource(vtxp); }

    std::string srcName(size_t) const override final { return ""; }
};
class DfgVertexVar VL_NOT_FINAL : public DfgVertex {
    // Represents a variable.
    DfgEdge m_srcs[2] = {DfgEdge{this}, DfgEdge{this}};
    AstVar* const m_varp;  // The AstVar associated with this vertex (not owned by this vertex)
    AstVarScope* const m_varScopep;  // The AstVarScope associated with this vertex (not owned)
    // Location of driver of this variable. Only used for converting back to Ast. Might be nullptr.
    FileLine* m_driverFileLine = nullptr;
    // If this DfgVertexVar is a synthesized temporary, this is the Var/VarScope it stands for.
    AstNode* m_tmpForp = nullptr;

    bool selfEquals(const DfgVertex& that) const final {
        UASSERT_OBJ(nodep() != that.as<DfgVertexVar>()->nodep(), this,
                    "There should only be one DfgVertexVar for a given AstVar/AstVarScope");
        return false;
    }

    V3Hash selfHash() const final {
        V3Hash hash;
        hash += nodep()->name();
        hash += varp()->varType();
        return hash;
    }

    DfgVertexVar(DfgGraph& dfg, VDfgType type, AstVar* varp, AstVarScope* vscp)
        : DfgVertex{dfg, type, varp->fileline(), V3Dfg::toDfgDType(varp->dtypep())}
        , m_varp{varp}
        , m_varScopep{vscp} {
#ifdef VL_DEBUG
        if (v3Global.rootp()->topScopep()) {
            UASSERT_OBJ(vscp, varp, "Un-scoped DfgVertexVar created in scoped DfgGraph");
        } else {
            UASSERT_OBJ(!vscp, varp, "Scoped DfgVertexVar created in un-scoped DfgGraph");
        }
#endif
        UASSERT_OBJ(V3Dfg::isSupported(dtypep()), varp, "Not representable by DfgVertexVar");
    }

protected:
    DfgVertexVar(DfgGraph& dfg, VDfgType type, AstVar* varp)
        : DfgVertexVar{dfg, type, varp, nullptr} {
        // Increment reference count
        varp->user1(varp->user1() + 0x10);
        UASSERT_OBJ((varp->user1() >> 4) > 0, varp, "Reference count overflow");
    }
    DfgVertexVar(DfgGraph& dfg, VDfgType type, AstVarScope* vscp)
        : DfgVertexVar{dfg, type, vscp->varp(), vscp} {
                    // Increment reference count
        vscp->user1(vscp->user1() + 0x10);
        UASSERT_OBJ((vscp->user1() >> 4) > 0, vscp, "Reference count overflow");
    }

public:
    ~DfgVertexVar() {
        // Decrement reference count
        AstNode* const variablep = nodep();
        variablep->user1(variablep->user1() - 0x10);
        UASSERT_OBJ((variablep->user1() >> 4) >= 0, variablep, "Reference count underflow");
    }

    ASTGEN_MEMBERS_DfgVertexVar;

    // The driver of the variable. Might be nullptr if driven exernally
    DfgVertex* srcp() const { return m_srcs[0].sourcep(); }
    void srcp(DfgVertex* vtxp) {
        if (vtxp) {
            m_srcs[0].relinkSource(vtxp);
        } else {
            m_srcs[0].unlinkSource();
        }
    }

    // The default value of the variable. This defines the parts not driven by 'srcp'
    DfgVertex* defaultp() { return m_srcs[1].sourcep(); }
    const DfgVertex* defaultp() const { return m_srcs[1].sourcep(); }
    void defaultp(DfgVertex* vtxp) {
        if (vtxp) {
            m_srcs[1].relinkSource(vtxp);
        } else {
            m_srcs[1].unlinkSource();
        }
     }

    // The Ast variable this vertex representess
    AstVar* varp() const { return m_varp; }
    AstVarScope* varScopep() const { return m_varScopep; }
    AstNode* nodep() const {
        return m_varScopep ? static_cast<AstNode*>(m_varScopep) : static_cast<AstNode*>(m_varp);
    }

    FileLine* driverFileLine() const { return m_driverFileLine; }
    void driverFileLine(FileLine* flp) { m_driverFileLine = flp; }

    AstNode* tmpForp() const { return m_tmpForp; }
    void tmpForp(AstNode* nodep) { m_tmpForp = nodep; }

    bool isDrivenFullyByDfg() const {
        return srcp() && !srcp()->is<DfgVertexSplice>() && !varp()->isForced()
               && !varp()->isSigUserRWPublic();
    }

    // Variable referenced via an AstVarXRef (hierarchical reference)
    bool hasXRefs() const { return nodep()->user1() & 0x03; }
    static void setHasRdXRefs(AstNode* nodep) { nodep->user1(nodep->user1() | 0x01); }
    static void setHasWrXRefs(AstNode* nodep) { nodep->user1(nodep->user1() | 0x02); }

    // Variable referenced from Ast code in the same module/netlist
    bool hasModRdRefs() const { return nodep()->user1() & 0x04; }
    bool hasModWrRefs() const { return nodep()->user1() & 0x08; }
    bool hasModRefs() const { return nodep()->user1() & 0x0c; }
    static void setHasModRdRefs(AstNode* nodep) { nodep->user1(nodep->user1() | 0x04); }
    static void setHasModWrRefs(AstNode* nodep) { nodep->user1(nodep->user1() | 0x08); }
    void setHasModRdRefs() const { setHasModRdRefs(nodep()); }
    void setHasModWrRefs() const { setHasModWrRefs(nodep()); }

    // Variable referenced from other DFG in the same module/netlist
    bool hasDfgRefs() const { return nodep()->user1() >> 5; }  // I.e.: (nodep()->user1() >> 4) > 1

    // Variable referenced outside the containing module/netlist.
    bool hasExtRefs() const {
        // In scoped mode, we can ignrore some of these as they were made explicit by then
        if (!m_varScopep) {
            if (m_varp->isIO()) return true;  // Ports
            if (m_varp->isTrace()) return true;  // Traced
            if (m_varp->isForced()) return true;  // Forced
            if (hasXRefs()) return true;  // Target of a hierarchical reference
        }
        if (m_varp->isPrimaryIO()) return true;  // Top level ports
        if (m_varp->isSigPublic()) return true;  // Public
        return false;
    }

    std::string srcName(size_t idx) const override final { return idx ? "defaultp" : "srcp" ; }
};
class DfgVertexVariadic VL_NOT_FINAL : public DfgVertex {
    std::deque<DfgEdge> m_srcs{};

protected:
    DfgEdge* addSource() {
        m_srcs.emplace_back(this);
        return &m_srcs.back();
    }

    DfgVertexVariadic(DfgGraph& dfg, VDfgType type, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertex{dfg, type, flp, dtypep} {}

    void unlinkSources() {
        for (DfgEdge& src : m_srcs) src.unlinkSource();
        m_srcs.clear();
    }

public:
    ASTGEN_MEMBERS_DfgVertexVariadic;

    size_t srcsSize() const { return m_srcs.size(); }

    DfgVertex* srcp(size_t idx) { return m_srcs.at(idx).sourcep(); }
    const DfgVertex* srcp(size_t idx) const { return m_srcs.at(idx).sourcep(); }
    void srcp(size_t idx, DfgVertex* vtxp) { return m_srcs.at(idx).relinkSource(vtxp); }
};
class DfgVertexSplice VL_NOT_FINAL : public DfgVertexVariadic {
protected:
    struct DriverData final {
        FileLine* m_flp;  // Location of this driver
        uint32_t m_lo;  // Low index of range driven by this driver
        DriverData() = delete;
        DriverData(FileLine* flp, uint32_t lo)
            : m_flp{flp}
            , m_lo{lo} {}
    };
    std::vector<DriverData> m_driverData;  // Additional data associated with each driver
    DfgEdge m_default{this};  // The default driver, stored separately

    bool selfEquals(const DfgVertex& that) const override final {
        const DfgVertexSplice* const thatp = that.as<DfgVertexSplice>();
        const size_t n = srcsSize();
        if (thatp->srcsSize() != n) return false;
        for (size_t i = 0; i < n; ++i) {
            if (m_driverData[i].m_lo != thatp->m_driverData[i].m_lo) return false;
        }
        return true;
    }
    V3Hash selfHash() const override final {
        V3Hash hash;
        const size_t n = srcsSize();
        for (size_t i = 0; i < n; ++i) hash += m_driverData[i].m_lo;
        return hash;
    }

    DfgVertexSplice(DfgGraph& dfg, VDfgType type, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertexVariadic{dfg, type, flp, dtypep} {}

public:
    ASTGEN_MEMBERS_DfgVertexSplice;

    // Add resolved driver
    void addDriver(FileLine* flp, uint32_t lo, DfgVertex* vtxp) {
        UASSERT_OBJ(!vtxp->is<DfgLogic>(), vtxp, "addDriver called with DfgLogic");
        m_driverData.emplace_back(flp, lo);
        DfgVertexVariadic::addSource()->relinkSource(vtxp);
    }

    FileLine* driverFileLine(size_t idx) const { return m_driverData.at(idx).m_flp; }

    DfgVertex* driverAt(size_t idx) {
        const size_t n = srcsSize();
        for (size_t i = 0; i < n; ++i) {
            if (m_driverData[i].m_lo == idx) return srcp(i);
        }
        return nullptr;
    }

    const DfgVertex* driverAt(size_t idx) const {
        for (const DriverData& dd : m_driverData) {
            if (dd.m_lo == idx) return srcp(idx);
        }
        return nullptr;
    }

    // If drives the whole result explicitly (not through defaultp), this is
    // the actual driver this DfgVertexSplice can be replaced with.
    inline DfgVertex* wholep();

    bool forDriver(std::function<bool(DfgVertex&, uint32_t, FileLine*)> f) {
        const size_t n = srcsSize();
        for (size_t i = 0; i < n; ++i) {
            if (f(*srcp(i), m_driverData[i].m_lo, m_driverData[i].m_flp)) return true;
        }
        return false;
    }
    bool forDriver(std::function<bool(const DfgVertex&, uint32_t, FileLine*)> f) const {
        const size_t n = srcsSize();
        for (size_t i = 0; i < n; ++i) {
            if (f(*srcp(i), m_driverData[i].m_lo, m_driverData[i].m_flp)) return true;
        }
        return false;
    }

    void resetDrivers() {
        unlinkSources();
        m_driverData.clear();
    }

    std::string srcName(size_t idx) const override final {
        const uint32_t lo = m_driverData[idx].m_lo;
        const uint32_t hi = lo + srcp(idx)->size() - 1;
        return '[' + std::to_string(hi) + ':' + std::to_string(lo) + ']';
    }
};

//------------------------------------------------------------------------------
// Concrete (and final) DfgVertex sub-types

// === DfgVertexBinary ===
class DfgMux final : public DfgVertexBinary {
    // AstSel is ternary, but the 'widthp' is always constant and is hence redundant, and
    // 'lsbp' is very often constant. As AstSel is fairly common, we special case as a DfgSel for
    // the constant 'lsbp', and as 'DfgMux` for the non-constant 'lsbp'.
    bool selfEquals(const DfgVertex&) const override { return true; }
    V3Hash selfHash() const override { return V3Hash{}; }

public:
    DfgMux(DfgGraph& dfg, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertexBinary{dfg, dfgType(), flp, dtypep} {}
    ASTGEN_MEMBERS_DfgMux;

    DfgVertex* fromp() const { return src0p(); }
    void fromp(DfgVertex* vtxp) { src0p(vtxp); }
    DfgVertex* lsbp() const { return src1p(); }
    void lsbp(DfgVertex* vtxp) { src1p(vtxp); }

    std::string srcName(size_t idx) const override { return idx ? "lsbp" : "fromp"; }
};


// === DfgVertexNullary ===
class DfgConst final : public DfgVertexNullary {
    friend class DfgVertex;
    friend class DfgVisitor;

    V3Number m_num;  // Constant value

    bool selfEquals(const DfgVertex& that) const override {
        return num().isCaseEq(that.as<DfgConst>()->num());
    }
    V3Hash selfHash() const override { return num().toHash(); }

public:
    DfgConst(DfgGraph& dfg, FileLine* flp, const V3Number& num)
        : DfgVertexNullary{dfg, dfgType(), flp, V3Dfg::dtypePacked(num.width())}
        , m_num{num} {}
    DfgConst(DfgGraph& dfg, FileLine* flp, uint32_t width, uint32_t value)
        : DfgVertexNullary{dfg, dfgType(), flp, V3Dfg::dtypePacked(width)}
        , m_num{flp, static_cast<int>(width), value} {}

    ASTGEN_MEMBERS_DfgConst;

    V3Number& num() { return m_num; }
    const V3Number& num() const { return m_num; }

    size_t toSizeT() const {
        if VL_CONSTEXPR_CXX17 (sizeof(size_t) > sizeof(uint32_t)) {
            return static_cast<size_t>(num().toUQuad());
        }
        return static_cast<size_t>(num().toUInt());
    }

    uint32_t toU32() const { return static_cast<size_t>(num().toUInt()); }

    // cppcheck-suppress duplInheritedMember
    bool isZero() const { return num().isEqZero(); }
    // cppcheck-suppress duplInheritedMember
    bool isOnes() const { return num().isEqAllOnes(width()); }

    // Does this DfgConst have the given value? Note this is not easy to answer if wider than 32.
    bool hasValue(uint32_t value) const {
        return !num().isFourState() && num().edataWord(0) == value && num().mostSetBitP1() <= 32;
    }
};

// === DfgVertexUnary ===
class DfgSel final : public DfgVertexUnary {
    // AstSel is ternary, but the 'widthp' is always constant and is hence redundant, and
    // 'lsbp' is very often constant. As AstSel is fairly common, we special case as a DfgSel for
    // the constant 'lsbp', and as 'DfgMux` for the non-constant 'lsbp'.
    uint32_t m_lsb = 0;  // The LSB index

    bool selfEquals(const DfgVertex& that) const override {
        return lsb() == that.as<DfgSel>()->lsb();
    }
    V3Hash selfHash() const override { return V3Hash{lsb()}; }

public:
    DfgSel(DfgGraph& dfg, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertexUnary{dfg, dfgType(), flp, dtypep} {}
    ASTGEN_MEMBERS_DfgSel;

    DfgVertex* fromp() const { return src0p(); }
    void fromp(DfgVertex* vtxp) { src0p(vtxp); }
    uint32_t lsb() const { return m_lsb; }
    void lsb(uint32_t value) { m_lsb = value; }
};
class DfgUnitArray final : public DfgVertexUnary {
    // This is a type adapter for modeling arrays. It's a single element array,
    // with the value of the single element being the source operand.

    bool selfEquals(const DfgVertex&) const final { return true; }
    V3Hash selfHash() const final { return V3Hash{}; }

public:
    DfgUnitArray(DfgGraph& dfg, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertexUnary{dfg, dfgType(), flp, dtypep} {
        UASSERT_OBJ(this->dtypep(), flp, "Non array DfgUnitArray");
        UASSERT_OBJ(this->size() == 1, flp, "DfgUnitArray must have a single element");
    }
    ASTGEN_MEMBERS_DfgUnitArray;
};

// === DfgVertexVar ===
class DfgVarArray final : public DfgVertexVar {
    friend class DfgVertex;
    friend class DfgVisitor;

public:
    DfgVarArray(DfgGraph& dfg, AstVar* varp)
        : DfgVertexVar{dfg, dfgType(), varp} {
        UASSERT_OBJ(VN_IS(dtypep(), UnpackArrayDType), varp, "Non array DfgVarArray");
    }
    DfgVarArray(DfgGraph& dfg, AstVarScope* vscp)
        : DfgVertexVar{dfg, dfgType(), vscp} {
        UASSERT_OBJ(VN_IS(dtypep(), UnpackArrayDType), vscp, "Non array DfgVarArray");
    }
    ASTGEN_MEMBERS_DfgVarArray;
};
class DfgVarPacked final : public DfgVertexVar {
    friend class DfgVertex;
    friend class DfgVisitor;

public:
    DfgVarPacked(DfgGraph& dfg, AstVar* varp)
        : DfgVertexVar{dfg, dfgType(), varp} {
        UASSERT_OBJ(!VN_IS(dtypep(), UnpackArrayDType), varp, "Array DfgVarPacked");
    }
    DfgVarPacked(DfgGraph& dfg, AstVarScope* vscp)
        : DfgVertexVar{dfg, dfgType(), vscp} {
        UASSERT_OBJ(!VN_IS(dtypep(), UnpackArrayDType), vscp, "Array DfgVarPacked");
    }
    ASTGEN_MEMBERS_DfgVarPacked;
};

// === DfgVertexVariadic ===
class DfgLogic final : public DfgVertexVariadic {
    // Generic vertex representing a whole combinational process
    AstNode* const m_nodep;  // The Ast logic represented by this vertex
    AstScope* const m_scopep;  // The AstScope m_nodep is under, iff scoped
    const std::unique_ptr<CfgGraph> m_cfgp;
    // Vertices this logic was synthesized into. Excluding variables
    std::vector<DfgVertex*> m_synth;

    // Used very early, should never be needed
    bool selfEquals(const DfgVertex&) const final { V3ERROR_NA_RETURN(false); }
    V3Hash selfHash() const final { V3ERROR_NA_RETURN(V3Hash{}); }

public:
    DfgLogic(DfgGraph& dfg, AstAssignW* nodep, AstScope* scopep)
        : DfgVertexVariadic{dfg, dfgType(), nodep->fileline(), nullptr}
        , m_nodep{nodep}
        , m_scopep{scopep}
        , m_cfgp{nullptr} {}

    DfgLogic(DfgGraph& dfg, AstAlways* nodep, AstScope* scopep, std::unique_ptr<CfgGraph> cfgp)
        : DfgVertexVariadic{dfg, dfgType(), nodep->fileline(), nullptr}
        , m_nodep{nodep}
        , m_scopep{scopep}
        , m_cfgp{std::move(cfgp)} {}

    ASTGEN_MEMBERS_DfgLogic;

    void addInput(DfgVertexVar* varp) { addSource()->relinkSource(varp); }

    AstNode* nodep() const { return m_nodep; }
    AstScope* scopep() const { return m_scopep; }
    CfgGraph& cfg() { return *m_cfgp; }
    const CfgGraph& cfg() const { return *m_cfgp; }
    std::vector<DfgVertex*>& synth() { return m_synth; }
    const std::vector<DfgVertex*>& synth() const { return m_synth; }

    std::string srcName(size_t) const override final { return ""; }
};
class DfgUnresolved final : public DfgVertexVariadic {
    // Represents a collection of unresolved variable drivers before synthesis

    bool selfEquals(const DfgVertex&) const final { return true; }
    V3Hash selfHash() const final { return V3Hash{}; }

public:
    DfgUnresolved(DfgGraph& dfg, const DfgVertexVar* vtxp)
        : DfgVertexVariadic{dfg, dfgType(), vtxp->fileline(), vtxp->dtypep()} {}
    ASTGEN_MEMBERS_DfgUnresolved;

    // Can only be driven by DfgLogic or DfgVertexSplice
    void addDriver(DfgLogic* vtxp) { addSource()->relinkSource(vtxp); }
    void addDriver(DfgVertexSplice* vtxp) { addSource()->relinkSource(vtxp); }

    std::string srcName(size_t) const override final { return ""; }
};

// === DfgVertexSplice ===
class DfgSpliceArray final : public DfgVertexSplice {
    friend class DfgVertex;
    friend class DfgVisitor;

public:
    DfgSpliceArray(DfgGraph& dfg, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertexSplice{dfg, dfgType(), flp, dtypep} {
        UASSERT_OBJ(VN_IS(dtypep, UnpackArrayDType), flp, "Non array DfgSpliceArray");
    }
    ASTGEN_MEMBERS_DfgSpliceArray;
};
class DfgSplicePacked final : public DfgVertexSplice {
    friend class DfgVertex;
    friend class DfgVisitor;

public:
    DfgSplicePacked(DfgGraph& dfg, FileLine* flp, AstNodeDType* dtypep)
        : DfgVertexSplice{dfg, dfgType(), flp, dtypep} {
        UASSERT_OBJ(!VN_IS(dtypep, UnpackArrayDType), flp, "Array DfgSplicePacked");
    }
    ASTGEN_MEMBERS_DfgSplicePacked;
};

// The rest of the DfgVertex subclasses are generated by 'astgen' from AstNodeExpr nodes
#include "V3Dfg__gen_auto_classes.h"

//------------------------------------------------------------------------------
// Inline method definitions

// DfgVertexSplice {{{
DfgVertex* DfgVertexSplice::wholep() {
    if (srcsSize() != 1) return nullptr;
    if (m_driverData[0].m_lo != 0) return nullptr;
    DfgVertex* const vtxp = srcp(0);
    if (vtxp->size() != size()) return nullptr;
    if (DfgUnitArray* const uap = vtxp->cast<DfgUnitArray>()) {
        if (DfgVertexSplice* const splicep = uap->srcp()->cast<DfgVertexSplice>()) {
            if (!splicep->wholep()) return nullptr;
        }
    }
    return vtxp;
}
// }}}

#endif
